"""
ğŸª Ù„Ø¹Ø¨Ø© "Ø¹Ù†Ø²ÙŠ ÙÙŠ Ø§Ù„Ø´Ù…Ø§Ù„" ğŸŒµ
Ù…ØºØ§Ù…Ø±Ø§Øª ÙÙŠ Ø´Ù…Ø§Ù„ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©
Ù…Ø·ÙˆØ± Ø¨Ù„ØºØ© Python Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Pygame

GitHub Repository: https://github.com/[Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…]/anzee-game
"""

import pygame
import random
import sys
import math

class AnzeeGame:
    def __init__(self):
        # ØªÙ‡ÙŠØ¦Ø© Pygame
        pygame.init()
        pygame.mixer.init()
        
        # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø´Ø§Ø´Ø©
        self.WIDTH, self.HEIGHT = 1024, 576
        self.screen = pygame.display.set_mode((self.WIDTH, self.HEIGHT))
        pygame.display.set_caption("ğŸª Ø¹Ù†Ø²ÙŠ ÙÙŠ Ø§Ù„Ø´Ù…Ø§Ù„ - Ù…ØºØ§Ù…Ø±Ø§Øª ÙÙŠ ØµØ­Ø§Ø±ÙŠ Ø§Ù„Ø´Ù…Ø§Ù„ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠ")
        
        # Ø§Ù„Ø£Ù„ÙˆØ§Ù†
        self.SKY_BLUE = (135, 206, 235)
        self.SAND_GOLD = (194, 178, 128)
        self.SAND_LIGHT = (210, 190, 140)
        self.MOUNTAIN_BROWN = (139, 69, 19)
        self.GREEN = (34, 139, 34)
        self.WHITE = (255, 255, 255)
        self.BLACK = (0, 0, 0)
        self.GOLD = (255, 215, 0)
        self.RED = (255, 0, 0)
        self.HEALTH_GREEN = (0, 255, 0)
        
        # Ø§Ù„Ø®Ø·ÙˆØ·
        self.font_large = pygame.font.SysFont("arial", 48, bold=True)
        self.font_medium = pygame.font.SysFont("arial", 32)
        self.font_small = pygame.font.SysFont("arial", 24)
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø³Ø·Ø­
        self.sky_surface = self.create_gradient_surface(self.WIDTH, self.HEIGHT, (100, 180, 255), self.SKY_BLUE)
        self.sand_texture = self.create_sand_texture()
        
        self.clock = pygame.time.Clock()
        self.running = True

    class Player:
        def __init__(self, game):
            self.game = game
            self.x = 100
            self.y = game.HEIGHT - 150
            self.width = 50
            self.height = 70
            self.speed = 7
            self.jump_power = 16
            self.is_jumping = False
            self.jump_count = self.jump_power
            self.health = 100
            self.max_health = 100
            self.coins = 0
            self.score = 0
            self.direction = 1
            self.invincible = 0
            self.animation_counter = 0
            self.walking = False
            
        def draw(self):
            self.animation_counter += 1
            
            # ØªØ£Ø«ÙŠØ± Ø§Ù„ÙˆÙ…ÙŠØ¶ Ø¹Ù†Ø¯ Ø§Ù„Ù…Ù†Ø§Ø¹Ø©
            if self.invincible > 0 and self.invincible % 8 < 4:
                return
                
            # Ø§Ù„Ø¬Ø³Ù… (Ø§Ù„Ø«ÙˆØ¨)
            body_color = (70, 130, 180)
            pygame.draw.ellipse(self.game.screen, body_color, (self.x, self.y, self.width, self.height))
            
            # Ø§Ù„Ø±Ø£Ø³
            head_radius = 20
            head_x = self.x + self.width // 2
            head_y = self.y - 5
            pygame.draw.circle(self.game.screen, (210, 180, 140), (head_x, head_y), head_radius)
            
            # Ø§Ù„ØºØªØ±Ø© (Ø§Ù„Ø´Ù…Ø§Øº)
            ghutra_points = [
                (head_x, head_y - head_radius),
                (head_x - 25, head_y - 10),
                (head_x + 25, head_y - 10)
            ]
            pygame.draw.polygon(self.game.screen, (255, 255, 255), ghutra_points)
            
            # Ø§Ù„Ø¹Ù‚Ø§Ù„
            pygame.draw.rect(self.game.screen, (0, 0, 0), (head_x - 20, head_y - 15, 40, 5))
            
            # Ø§Ù„Ø¹ÙŠÙˆÙ†
            eye_offset = 8 * self.direction
            pygame.draw.circle(self.game.screen, self.game.BLACK, (head_x - eye_offset, head_y - 2), 4)
            
            # ØªØ£Ø«ÙŠØ± Ø§Ù„Ø­Ø±ÙƒØ©
            if self.walking:
                leg_offset = math.sin(self.animation_counter * 0.3) * 5
                pygame.draw.rect(self.game.screen, (50, 50, 50), (self.x + 10, self.y + self.height - 10, 8, 25 + leg_offset))
                pygame.draw.rect(self.game.screen, (50, 50, 50), (self.x + self.width - 18, self.y + self.height - 10, 8, 25 - leg_offset))
            else:
                pygame.draw.rect(self.game.screen, (50, 50, 50), (self.x + 10, self.y + self.height - 10, 8, 25))
                pygame.draw.rect(self.game.screen, (50, 50, 50), (self.x + self.width - 18, self.y + self.height - 10, 8, 25))
            
            # Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†
            arm_offset = math.sin(self.animation_counter * 0.2) * 3 if self.walking else 0
            pygame.draw.rect(self.game.screen, (210, 180, 140), (self.x - 5, self.y + 20, 8, 30 + arm_offset))
            pygame.draw.rect(self.game.screen, (210, 180, 140), (self.x + self.width - 3, self.y + 20, 8, 30 - arm_offset))
        
        def move(self, keys):
            self.walking = False
            
            if keys[pygame.K_LEFT]:
                self.x -= self.speed
                self.direction = -1
                self.walking = True
            if keys[pygame.K_RIGHT]:
                self.x += self.speed
                self.direction = 1
                self.walking = True
            
            # Ø§Ù„Ø­Ø¯ÙˆØ¯
            self.x = max(0, min(self.game.WIDTH - self.width, self.x))
            
            if self.invincible > 0:
                self.invincible -= 1
        
        def jump(self):
            if not self.is_jumping:
                self.is_jumping = True
        
        def update_jump(self):
            if self.is_jumping:
                if self.jump_count >= -self.jump_power:
                    neg = 1
                    if self.jump_count < 0:
                        neg = -1
                    self.y -= (self.jump_count ** 2) * 0.25 * neg
                    self.jump_count -= 1
                else:
                    self.is_jumping = False
                    self.jump_count = self.jump_power

    class Character:
        def __init__(self, game, x, y, char_type):
            self.game = game
            self.x = x
            self.y = y
            self.width = 40
            self.height = 60
            self.type = char_type
            self.speed = random.uniform(1.0, 2.5)
            self.direction = random.choice([-1, 1])
            self.interaction_cooldown = 0
            self.walk_counter = 0
            
            if self.type == 'friendly':
                self.color = (0, 150, 0)
                self.name = "Ø§Ù„Ø¨Ø¯ÙˆÙŠ Ø§Ù„Ø·ÙŠØ¨"
            elif self.type == 'aggressive':
                self.color = (200, 0, 0)
                self.name = "Ø§Ù„Ù„Øµ"
            else:
                self.color = (128, 0, 128)
                self.name = "Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„ØºØ§Ù…Ø¶"
        
        def draw(self):
            self.walk_counter += 1
            
            # Ø§Ù„Ø¬Ø³Ù…
            pygame.draw.ellipse(self.game.screen, self.color, (self.x, self.y, self.width, self.height))
            
            # Ø§Ù„Ø±Ø£Ø³
            head_radius = 15
            head_x = self.x + self.width // 2
            head_y = self.y - 5
            pygame.draw.circle(self.game.screen, (210, 180, 140), (head_x, head_y), head_radius)
            
            # Ø§Ù„Ù…Ù„Ø§Ø¨Ø³ Ø§Ù„Ù…Ø®ØªÙ„ÙØ© Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
            if self.type == 'friendly':
                pygame.draw.arc(self.game.screen, (100, 50, 0), (self.x - 5, self.y, self.width + 10, 40), 0, math.pi, 3)
            elif self.type == 'aggressive':
                pygame.draw.line(self.game.screen, (101, 67, 33), (self.x + self.width, self.y + 20), (self.x + self.width + 20, self.y + 10), 3)
            
            # Ø§Ù„Ø­Ø±ÙƒØ©
            leg_offset = math.sin(self.walk_counter * 0.3) * 4
            pygame.draw.rect(self.game.screen, (50, 50, 50), (self.x + 8, self.y + self.height - 10, 6, 20 + leg_offset))
            pygame.draw.rect(self.game.screen, (50, 50, 50), (self.x + self.width - 14, self.y + self.height - 10, 6, 20 - leg_offset))
        
        def move(self):
            self.x += self.speed * self.direction
            
            if self.x <= 50 or self.x >= self.game.WIDTH - self.width - 50:
                self.direction *= -1
        
        def interact(self, player):
            if self.interaction_cooldown > 0:
                self.interaction_cooldown -= 1
                return None
            
            distance = math.sqrt((self.x - player.x)**2 + (self.y - player.y)**2)
            
            if distance < 60:
                if self.type == 'friendly':
                    player.coins += random.randint(1, 3)
                    player.score += 15
                    self.interaction_cooldown = 90
                    return f"{self.name}: ØªÙØ¶Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù‡Ø¯ÙŠØ© ÙŠØ§ Ø¨Ù†ÙŠ!"
                
                elif self.type == 'aggressive':
                    if player.invincible == 0:
                        player.health -= 15
                        player.invincible = 45
                    self.interaction_cooldown = 90
                    return f"{self.name}: Ø§ØªØ±Ùƒ Ù…Ù…ØªÙ„ÙƒØ§ØªÙƒ!"
                
                else:
                    effect = random.choice(['help', 'harm', 'coin'])
                    if effect == 'help':
                        player.health = min(player.max_health, player.health + 20)
                        self.interaction_cooldown = 90
                        return f"{self.name}: Ù‡Ø°Ù‡ Ù‡Ø¯ÙŠØ© Ù„Ø´Ø¬Ø§Ø¹ØªÙƒ!"
                    elif effect == 'coin':
                        player.coins += 5
                        player.score += 25
                        self.interaction_cooldown = 90
                        return f"{self.name}: ØªØ¬Ø§Ø±Ø© Ù…Ø±Ø¨Ø­Ø© Ø§Ù„ÙŠÙˆÙ…!"
                    else:
                        if player.invincible == 0:
                            player.health -= 10
                            player.invincible = 45
                        self.interaction_cooldown = 90
                        return f"{self.name}: Ø§Ù„ØµÙÙ‚Ø© Ù„Ù… ØªÙƒÙ† Ù„ØµØ§Ù„Ø­Ùƒ!"
            
            return None

    class Coin:
        def __init__(self, game):
            self.game = game
            self.x = random.randint(100, game.WIDTH - 100)
            self.y = random.randint(100, game.HEIGHT - 200)
            self.radius = 12
            self.collected = False
            self.animation_counter = random.randint(0, 100)
            self.float_height = random.uniform(0, 5)
        
        def draw(self):
            if not self.collected:
                self.animation_counter += 1
                self.float_height = 3 * math.sin(self.animation_counter * 0.1)
                
                # Ø¹Ù…Ù„Ø© Ø°Ù‡Ø¨ÙŠØ© Ù„Ø§Ù…Ø¹Ø©
                pygame.draw.circle(self.game.screen, self.game.GOLD, (self.x, self.y + self.float_height), self.radius)
                pygame.draw.circle(self.game.screen, (255, 235, 100), (self.x, self.y + self.float_height), self.radius - 3)
                
                # Ø¨Ø±ÙŠÙ‚
                sparkle_angle = self.animation_counter * 0.5
                sparkle_x = self.x + math.cos(sparkle_angle) * 6
                sparkle_y = self.y + self.float_height + math.sin(sparkle_angle) * 6
                pygame.draw.circle(self.game.screen, self.game.WHITE, (int(sparkle_x), int(sparkle_y)), 2)
        
        def collect(self, player):
            if self.collected:
                return False
                
            distance = math.sqrt((self.x - player.x)**2 + (self.y - player.y)**2)
            if distance < 40:
                self.collected = True
                player.coins += 1
                player.score += 10
                return True
            return False

    class PowerUp:
        def __init__(self, game, power_type):
            self.game = game
            self.x = random.randint(100, game.WIDTH - 100)
            self.y = random.randint(100, game.HEIGHT - 200)
            self.radius = 15
            self.type = power_type
            self.collected = False
            self.animation_counter = 0
            
            if self.type == 'health':
                self.color = (255, 0, 0)
                self.name = "â™¥ ØµØ­Ø©"
            elif self.type == 'speed':
                self.color = (0, 0, 255)
                self.name = "âš¡ Ø³Ø±Ø¹Ø©"
            else:
                self.color = (0, 255, 0)
                self.name = "ğŸ¦˜ Ù‚ÙØ²"
        
        def draw(self):
            if not self.collected:
                self.animation_counter += 1
                float_height = 4 * math.sin(self.animation_counter * 0.1)
                
                pygame.draw.circle(self.game.screen, self.color, (self.x, self.y + float_height), self.radius)
                pygame.draw.circle(self.game.screen, self.game.WHITE, (self.x, self.y + float_height), self.radius - 5)
        
        def collect(self, player):
            if self.collected:
                return False
                
            distance = math.sqrt((self.x - player.x)**2 + (self.y - player.y)**2)
            if distance < 45:
                self.collected = True
                if self.type == 'health':
                    player.health = min(player.max_health, player.health + 30)
                elif self.type == 'speed':
                    player.speed += 2
                else:
                    player.jump_power += 3
                return True
            return False

    def create_gradient_surface(self, width, height, color1, color2, vertical=True):
        surface = pygame.Surface((width, height))
        if vertical:
            for y in range(height):
                ratio = y / height
                r = int(color1[0] * (1 - ratio) + color2[0] * ratio)
                g = int(color1[1] * (1 - ratio) + color2[1] * ratio)
                b = int(color1[2] * (1 - ratio) + color2[2] * ratio)
                pygame.draw.line(surface, (r, g, b), (0, y), (width, y))
        else:
            for x in range(width):
                ratio = x / width
                r = int(color1[0] * (1 - ratio) + color2[0] * ratio)
                g = int(color1[1] * (1 - ratio) + color2[1] * ratio)
                b = int(color1[2] * (1 - ratio) + color2[2] * ratio)
                pygame.draw.line(surface, (r, g, b), (x, 0), (x, height))
        return surface

    def create_sand_texture(self):
        texture = pygame.Surface((100, 100))
        texture.fill(self.SAND_GOLD)
        for _ in range(200):
            x, y = random.randint(0, 99), random.randint(0, 99)
            radius = random.randint(1, 3)
            shade = random.choice([self.SAND_LIGHT, (180, 160, 120)])
            pygame.draw.circle(texture, shade, (x, y), radius)
        return texture

    def draw_palm_tree(self, x, y):
        # Ø§Ù„Ø¬Ø°Ø¹
        trunk_points = [
            (x, y),
            (x - 10, y - 80),
            (x - 5, y - 160),
            (x + 5, y - 160),
            (x + 10, y - 80)
        ]
        pygame.draw.polygon(self.screen, (101, 67, 33), trunk_points)
        
        # Ø§Ù„Ø³Ø¹Ù
        for angle in range(0, 360, 45):
            rad = math.radians(angle)
            end_x = x + math.cos(rad) * 40
            end_y = y - 160 + math.sin(rad) * 40
            pygame.draw.line(self.screen, self.GREEN, (x, y - 160), (end_x, end_y), 3)
            
            for i in range(1, 4):
                leaf_x = x + math.cos(rad) * 15 * i
                leaf_y = y - 160 + math.sin(rad) * 15 * i
                pygame.draw.circle(self.screen, (0, 100, 0), (int(leaf_x), int(leaf_y)), 8)

    def draw_tent(self, x, y):
        # Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø®ÙŠÙ…Ø©
        points = [
            (x, y),
            (x - 60, y - 40),
            (x + 60, y - 40)
        ]
        pygame.draw.polygon(self.screen, (165, 42, 42), points)
        
        # ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø®ÙŠÙ…Ø©
        pygame.draw.line(self.screen, self.BLACK, (x, y), (x, y - 40), 2)
        pygame.draw.line(self.screen, self.BLACK, (x - 30, y - 20), (x + 30, y - 20), 2)
        
        # Ø¨Ø§Ø¨ Ø§Ù„Ø®ÙŠÙ…Ø©
        pygame.draw.rect(self.screen, (100, 30, 30), (x - 15, y - 10, 30, 10))

    def draw_camel(self, x, y, facing_right=True):
        direction = 1 if facing_right else -1
        
        # Ø§Ù„Ø¬Ø³Ù…
        pygame.draw.ellipse(self.screen, (210, 180, 140), (x, y - 30, 80 * direction, 40))
        
        # Ø§Ù„Ø±Ù‚Ø¨Ø© ÙˆØ§Ù„Ø±Ø£Ø³
        pygame.draw.ellipse(self.screen, (210, 180, 140), (x + 60 * direction, y - 60, 30 * direction, 50))
        
        # Ø§Ù„Ø£Ø±Ø¬Ù„
        for i in range(4):
            leg_x = x + 20 + i * 15 * direction
            pygame.draw.rect(self.screen, (210, 180, 140), (leg_x, y + 10, 8 * direction, 25))
        
        # Ø§Ù„Ø³Ù†Ø§Ù…
        pygame.draw.ellipse(self.screen, (200, 170, 130), (x + 30 * direction, y - 50, 25 * direction, 35))

    def draw_well(self, x, y):
        # Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨Ø¦Ø±
        pygame.draw.rect(self.screen, (150, 75, 0), (x - 25, y - 20, 50, 30))
        pygame.draw.rect(self.screen, (100, 50, 0), (x - 20, y - 25, 40, 10))
        
        # Ø§Ù„Ø±Ø§ÙØ¹Ø©
        pygame.draw.rect(self.screen, (101, 67, 33), (x - 30, y - 60, 5, 60))
        pygame.draw.rect(self.screen, (101, 67, 33), (x + 25, y - 60, 5, 60))
        pygame.draw.rect(self.screen, (101, 67, 33), (x - 30, y - 60, 60, 5))
        
        # Ø§Ù„Ø¯Ù„Ùˆ
        pygame.draw.rect(self.screen, (150, 75, 0), (x, y - 45, 15, 10))

    def draw_background(self):
        # Ø§Ù„Ø³Ù…Ø§Ø¡
        self.screen.blit(self.sky_surface, (0, 0))
        
        # Ø§Ù„Ø´Ù…Ø³
        sun_x, sun_y = 850, 80
        pygame.draw.circle(self.screen, (255, 255, 200), (sun_x, sun_y), 50)
        pygame.draw.circle(self.screen, (255, 255, 100), (sun_x, sun_y), 40)
        
        # Ø§Ù„Ø¬Ø¨Ø§Ù„
        for i in range(5):
            mountain_x = i * 250 - 50
            points = [
                (mountain_x, self.HEIGHT - 100),
                (mountain_x + 150, self.HEIGHT - 300),
                (mountain_x + 300, self.HEIGHT - 100)
            ]
            pygame.draw.polygon(self.screen, self.MOUNTAIN_BROWN, points)
            # Ø«Ù„ÙˆØ¬ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù…Ù…
            pygame.draw.polygon(self.screen, self.WHITE, [
                (mountain_x + 120, self.HEIGHT - 300),
                (mountain_x + 150, self.HEIGHT - 330),
                (mountain_x + 180, self.HEIGHT - 300)
            ])
        
        # Ø§Ù„Ø£Ø±Ø¶ Ù…Ø¹ Ù†Ø³ÙŠØ¬ Ø§Ù„Ø±Ù…Ø§Ù„
        for x in range(0, self.WIDTH, 100):
            for y in range(self.HEIGHT - 100, self.HEIGHT, 100):
                self.screen.blit(self.sand_texture, (x, y))
        
        # Ø§Ù„Ù†Ø®ÙŠÙ„
        self.draw_palm_tree(200, self.HEIGHT - 100)
        self.draw_palm_tree(800, self.HEIGHT - 100)
        
        # Ø§Ù„Ø®ÙŠØ§Ù…
        self.draw_tent(400, self.HEIGHT - 100)
        self.draw_tent(600, self.HEIGHT - 100)
        
        # Ø§Ù„Ø¬Ù…Ø§Ù„
        self.draw_camel(300, self.HEIGHT - 120, True)
        self.draw_camel(700, self.HEIGHT - 120, False)
        
        # Ø§Ù„Ø¢Ø¨Ø§Ø±
        self.draw_well(500, self.HEIGHT - 100)

    def draw_ui(self, player, message, message_timer):
        # Ø´Ø±ÙŠØ· Ø§Ù„ØµØ­Ø©
        health_width = 200
        health_height = 20
        health_x = 20
        health_y = 20
        
        # Ø®Ù„ÙÙŠØ© Ø´Ø±ÙŠØ· Ø§Ù„ØµØ­Ø©
        pygame.draw.rect(self.screen, (50, 50, 50), (health_x, health_y, health_width, health_height))
        
        # Ø§Ù„ØµØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        health_percent = player.health / player.max_health
        current_health_width = int(health_width * health_percent)
        
        # ØªØ¯Ø±Ø¬ Ù„ÙˆÙ†ÙŠ Ù„Ù„ØµØ­Ø©
        if health_percent > 0.6:
            health_color = self.HEALTH_GREEN
        elif health_percent > 0.3:
            health_color = (255, 255, 0)
        else:
            health_color = self.RED
            
        pygame.draw.rect(self.screen, health_color, (health_x, health_y, current_health_width, health_height))
        
        # Ù†Øµ Ø§Ù„ØµØ­Ø©
        health_text = self.font_small.render(f"Ø§Ù„ØµØ­Ø©: {player.health}/{player.max_health}", True, self.WHITE)
        self.screen.blit(health_text, (health_x, health_y + 25))
        
        # Ø§Ù„Ø¹Ù…Ù„Ø§Øª ÙˆØ§Ù„Ù†Ù‚Ø§Ø·
        coins_text = self.font_small.render(f"Ø§Ù„Ø¹Ù…Ù„Ø§Øª: {player.coins} ğŸª™", True, self.WHITE)
        score_text = self.font_small.render(f"Ø§Ù„Ù†Ù‚Ø§Ø·: {player.score} â­", True, self.WHITE)
        
        self.screen.blit(coins_text, (self.WIDTH - 200, 20))
        self.screen.blit(score_text, (self.WIDTH - 200, 50))
        
        # Ø§Ù„Ø±Ø³Ø§Ù„Ø©
        if message_timer > 0:
            message_surface = self.font_small.render(message, True, self.WHITE)
            message_rect = message_surface.get_rect(center=(self.WIDTH//2, 50))
            
            # Ø®Ù„ÙÙŠØ© Ù„Ù„Ø±Ø³Ø§Ù„Ø©
            pygame.draw.rect(self.screen, (0, 0, 0, 128), 
                            (message_rect.x - 10, message_rect.y - 5, 
                             message_rect.width + 20, message_rect.height + 10),
                            border_radius=10)
            
            self.screen.blit(message_surface, message_rect)

    def show_start_screen(self):
        self.screen.fill((30, 60, 90))
        
        # Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ù…Ø¹ ØªØ£Ø«ÙŠØ±
        title_text = self.font_large.render("ğŸª Ø¹Ù†Ø²ÙŠ ÙÙŠ Ø§Ù„Ø´Ù…Ø§Ù„ ğŸŒµ", True, self.WHITE)
        subtitle_text = self.font_medium.render("Ù…ØºØ§Ù…Ø±Ø§Øª ÙÙŠ ØµØ­Ø§Ø±ÙŠ Ø§Ù„Ø´Ù…Ø§Ù„ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠ", True, (255, 255, 200))
        
        # ØªØ¹Ù„ÙŠÙ…Ø§Øª
        controls = [
            "Ø§Ù„ØªØ­ÙƒÙ…:",
            "â¡ï¸ â¬…ï¸ - Ø§Ù„Ø­Ø±ÙƒØ© ÙŠÙ…ÙŠÙ†Ø§Ù‹ ÙˆÙŠØ³Ø§Ø±Ø§Ù‹",
            "ğŸ”¼ - Ø§Ù„Ù‚ÙØ²", 
            "ESC - Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ù„Ø¹Ø¨Ø©",
            "",
            "Ø§Ø¶ØºØ· Ø£ÙŠ Ø²Ø± Ù„Ù„Ø¨Ø¯Ø¡..."
        ]
        
        self.screen.blit(title_text, (self.WIDTH//2 - title_text.get_width()//2, 100))
        self.screen.blit(subtitle_text, (self.WIDTH//2 - subtitle_text.get_width()//2, 170))
        
        # Ø±Ø³Ù… Ø¨Ø¹Ø¶ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù„Ù„Ø®Ù„ÙÙŠØ©
        self.draw_camel(200, 400, True)
        self.draw_tent(self.WIDTH//2, 400)
        self.draw_palm_tree(self.WIDTH - 200, 400)
        
        # ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„ØªØ­ÙƒÙ…
        for i, line in enumerate(controls):
            control_text = self.font_small.render(line, True, self.WHITE)
            self.screen.blit(control_text, (self.WIDTH//2 - control_text.get_width()//2, 250 + i * 30))
        
        pygame.display.flip()
        
        waiting = True
        while waiting:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN:
                    waiting = False

    def game_over_screen(self, score):
        overlay = pygame.Surface((self.WIDTH, self.HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        
        game_over_text = self.font_large.render("Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!", True, self.RED)
        score_text = self.font_medium.render(f"Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: {score}", True, self.WHITE)
        restart_text = self.font_small.render("Ø§Ø¶ØºØ· R Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø£Ùˆ ESC Ù„Ù„Ø®Ø±ÙˆØ¬", True, self.WHITE)
        
        self.screen.blit(game_over_text, (self.WIDTH//2 - game_over_text.get_width()//2, self.HEIGHT//2 - 60))
        self.screen.blit(score_text, (self.WIDTH//2 - score_text.get_width()//2, self.HEIGHT//2))
        self.screen.blit(restart_text, (self.WIDTH//2 - restart_text.get_width()//2, self.HEIGHT//2 + 60))
        
        pygame.display.flip()
        
        waiting = True
        while waiting:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_r:
                        return True
                    if event.key == pygame.K_ESCAPE:
                        return False
        return False

    def main_game(self):
        player = self.Player(self)
        characters = [self.Character(self, random.randint(100, self.WIDTH-100), self.HEIGHT-150, 
                                  random.choice(['friendly', 'aggressive', 'mysterious'])) 
                     for _ in range(6)]
        coins = [self.Coin(self) for _ in range(15)]
        powerups = [self.PowerUp(self, random.choice(['health', 'speed', 'jump'])) for _ in range(3)]
        
        message = ""
        message_timer = 0
        
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    return False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        player.jump()
                    if event.key == pygame.K_ESCAPE:
                        return True
            
            keys = pygame.key.get_pressed()
            player.move(keys)
            player.update_jump()
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
            for char in characters:
                char.move()
                msg = char.interact(player)
                if msg:
                    message = msg
                    message_timer = 180
            
            # Ø¬Ù…Ø¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª
            for coin in coins:
                if coin.collect(player):
                    coins.remove(coin)
                    coins.append(self.Coin(self))
            
            # Ø¬Ù…Ø¹ Ø§Ù„Ø¨Ø§ÙˆØ±Ø§Ø¨Ø§Øª
            for powerup in powerups[:]:
                if powerup.collect(player):
                    powerups.remove(powerup)
                    message = f"Ø­ØµÙ„Øª Ø¹Ù„Ù‰: {powerup.name}!"
                    message_timer = 120
                    powerups.append(self.PowerUp(self, random.choice(['health', 'speed', 'jump'])))
            
            # Ø§Ù„Ø±Ø³Ù…
            self.draw_background()
            
            for coin in coins:
                coin.draw()
            
            for powerup in powerups:
                powerup.draw()
            
            for char in characters:
                char.draw()
            
            player.draw()
            self.draw_ui(player, message, message_timer)
            
            # Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©
            if player.health <= 0:
                if self.game_over_screen(player.score):
                    return True
                else:
                    return False
            
            pygame.display.flip()
            self.clock.tick(60)
        
        return True

    def run(self):
        """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©"""
        while True:
            self.show_start_screen()
            if not self.main_game():
                break
        
        pygame.quit()
        sys.exit()

def main():
    """Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    game = AnzeeGame()
    game.run()

if __name__ == "__main__":
    main()
